#!/opt/pwn.college/python
import sys
sys.path.append('/challenge')

from paceAITester.verify_helpers import extract_python_details, find_function_call


def print_flag():
    try:
        with open("/flag", "r") as f:
            print(f.read())
    except FileNotFoundError:
        print("Error: Flag file not found.")

""" Starter code
from sklearn.datasets import load_iris
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split

# Initializing the data
iris = load_iris()
X = iris.data
y = iris.target
"""

# Variable names
X_train_var = None
X_test_var = None
y_train_var = None
y_test_var = None
model_var = None
y_pred_var = None
mse_var = None


# {'variable': 'model', 'function': 'LogisticRegression', 'args': [], 'kwargs': {}}
# {'variable': None, 'function': 'model.fit', 'args': ['X_train', 'y_train'], 'kwargs': {}}
# {'variable': 'y_pred', 'function': 'model.predict', 'args': ['X_test'], 'kwargs': {}}
# {'variable': 'accuracy', 'function': 'accuracy_score', 'args': ['y_test', 'y_pred'], 'kwargs': {}}
# {'variable': None, 'function': 'print', 'args': ["'Accuracy:'", 'accuracy'], 'kwargs': {}}


def step_1_check(lines: list[dict]):
    """
    Step Goal: Split the dataset where the test dataset is 20% of the original and set a random state of 42

    :param lines: List of dictionaries containing Python function calls from input file
    :type lines: list[dict]
    :return: A tuple containing a boolean indicating success or failure of the validation,
             and a string message providing error details if failure
    :rtype: tuple[bool, str]
    """
    # {'variable': ('X_train', 'X_test', 'y_train', 'y_test'), 'function': 'train_test_split', 'args': ['X', 'y'], 'kwargs': {'test_size': '0.2', 'random_state': '42'}}
    global X_train_var
    global X_test_var
    global y_train_var
    global y_test_var
    function_calls = find_function_call(lines, 'train_test_split')

    # Check if function is called
    if len(function_calls) == 0:
        return False, "train_test_split() isn't called"

    # Make sure function isn't called more than once
    if len(function_calls) > 1:
        return False, 'train_test_split() only needs to be called once'
    
    function_call = function_calls[0]

    # Make sure result is stored in 4 variables
    if function_call['variable'] is None:
        return False, "Make sure to store the result of train_test_split() in your train and test dataset variables"
    
    if len(function_call['variable']) != 4:
        return False, "The result of train_test_split() should be stored in 4 variables (train inputs, test inputs, train outputs, test outputs)"

    X_train_var, X_test_var, y_train_var, y_test_var = function_call['variable']

    # Make sure args is correct
    solution_args = ['X', 'y']
    if function_call['args'] != solution_args:
        return False, "Did you correctly pass 'X' and 'y' to train_test_split()?"

    # Make sure kwargs is correct
    solution_kwargs = {'test_size': '0.2', 'random_state': '42'}
    if function_call['kwargs'] != solution_kwargs:
        return False, "Did you supply train_test_split() with the correct values for the parameters 'test_size' and 'random_state'?"

    return True, ''


def step_2_check(lines: list[dict]):
    """
    Step Goal: Initialize a logistic regression model

    :param lines: List of dictionaries containing Python function calls from input file
    :type lines: list[dict]
    :return: A tuple containing a boolean indicating success or failure of the validation,
             and a string message providing error details if failure
    :rtype: tuple[bool, str]
    """
    return True, ''


def step_3_check(lines: list[dict]):
    """
    Step Goal: Train the logistic regression model on the iris dataset

    :param lines: List of dictionaries containing Python function calls from input file
    :type lines: list[dict]
    :return: A tuple containing a boolean indicating success or failure of the validation,
             and a string message providing error details if failure
    :rtype: tuple[bool, str]
    """
    return True, ''


def step_4_check(lines: list[dict]):
    """
    Step Goal: Make predictions on the test iris dataset

    :param lines: List of dictionaries containing Python function calls from input file
    :type lines: list[dict]
    :return: A tuple containing a boolean indicating success or failure of the validation,
             and a string message providing error details if failure
    :rtype: tuple[bool, str]
    """
    return True, ''


def step_5_check(lines: list[dict]):
    """
    Step Goal: Retrieve the model's test dataset accuracy and print it out

    :param lines: List of dictionaries containing Python function calls from input file
    :type lines: list[dict]
    :return: A tuple containing a boolean indicating success or failure of the validation,
             and a string message providing error details if failure
    :rtype: tuple[bool, str]
    """
    return True, ''


def step_6_check(lines: list[dict]):
    """
    Step Goal: Print out the model's accuracy

    :param lines: List of dictionaries containing Python function calls from input file
    :type lines: list[dict]
    :return: A tuple containing a boolean indicating success or failure of the validation,
             and a string message providing error details if failure
    :rtype: tuple[bool, str]
    """
    return True, ''


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print('Usage: verify <user_script>.py')
        sys.exit(1)
    
    script_path = sys.argv[1]
    lines = extract_python_details(script_path)

    red_text_code = '\033[31m'
    green_text_code = '\033[32m'
    reset_code = '\033[0m'

    checks = [step_1_check, step_2_check, step_3_check, step_4_check, step_5_check, step_6_check]
    for i in range(len(checks)):
        check_func = checks[i]
        is_correct, error_msg = check_func(lines)
        if is_correct:
            print(f'{green_text_code}Step {i + 1} Passed{reset_code}')
        else:
            print(f'{red_text_code}Step {i + 1} Failed{reset_code}')
            print(error_msg)
            sys.exit(1)
    
    print('Congratulations! You have passed this challenge! Here is your flag:')
    print_flag()
