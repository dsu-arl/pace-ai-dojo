#!/opt/pwn.college/python
import sys
import ast


sys.path.append('/challenge')


def print_flag():
    try:
        with open("/flag", "r") as f:
            print(f.read())
    except FileNotFoundError:
        print("Error: Flag file not found.")


def unparse(node):
    """A backport of ast.unparse for Python 3.8."""
    import ast

    class _Unparser(ast.NodeVisitor):
        def __init__(self):
            self.result = ""

        def visit_Module(self, node):
            for stmt in node.body:
                self.visit(stmt)

        def visit_Expr(self, node):
            self.visit(node.value)
            self.result += "\n"

        def visit_Assign(self, node):
            for target in node.targets:
                self.visit(target)
                self.result += " = "
            self.visit(node.value)
            self.result += "\n"

        def visit_Name(self, node):
            self.result += node.id

        def visit_Constant(self, node):
            self.result += repr(node.value)

        def visit_BinOp(self, node):
            self.visit(node.left)
            self.result += f" {self.operator(node.op)} "
            self.visit(node.right)

        def visit_Attribute(self, node):
            # Handles attribute access like model.fit
            self.visit(node.value)  # Visit the base (e.g., model)
            self.result += f".{node.attr}"  # Append the attribute name (e.g., fit)

        def visit_Call(self, node):
            # Handles function/method calls like model.fit()
            self.visit(node.func)  # Visit the function being called
            self.result += "("
            for i, arg in enumerate(node.args):
                if i > 0:
                    self.result += ", "
                self.visit(arg)  # Visit each argument
            self.result += ")"

        def visit_arguments(self, node):
            # Handle arguments for function definitions (not relevant here)
            pass

        def operator(self, op):
            if isinstance(op, ast.Add):
                return "+"
            if isinstance(op, ast.Sub):
                return "-"
            if isinstance(op, ast.Mult):
                return "*"
            if isinstance(op, ast.Div):
                return "/"
            raise NotImplementedError(f"Operator {op} not implemented")

    unparser = _Unparser()
    unparser.visit(node)
    return unparser.result


def extract_python_details(filepath):
    with open(filepath, 'r') as file:
        tree = ast.parse(file.read(), filename=filepath)

    lines = []
    for node in ast.walk(tree):
        # Handle assignment: variable = function(...)
        if isinstance(node, ast.Assign) and isinstance(node.value, ast.Call):
            # Handle unpacked variables (tuple or list)
            if isinstance(node.targets[0], (ast.Tuple, ast.List)):
                variable = tuple(unparse(var) for var in node.targets[0].elts)
            # Single variable assignment
            elif isinstance(node.targets[0], ast.Name):
                variable = node.targets[0].id if node.targets[0].id != '_' else None
            else:
                variable = None
            
            func = unparse(node.value.func)
            args = [unparse(arg) for arg in node.value.args]
            kwargs = {kw.arg: unparse(kw.value) for kw in node.value.keywords}

            lines.append({
                'variable': variable,
                'function': func,
                'args': args,
                'kwargs': kwargs
            })

        # Handle standalone function calls like model.fit(...)
        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.Call):
            func = unparse(node.value.func)
            args = [unparse(arg) for arg in node.value.args]
            kwargs = {kw.arg: unparse(kw.value) for kw in node.value.keywords}

            lines.append({
                'variable': None,
                'function': func,
                'args': args,
                'kwargs': kwargs
            })
    
    return lines


def find_function_call(lines, function_name):
    function_calls = []
    for line in lines:
        if line['function'] == function_name:
            function_calls.append(line)
    return function_calls


# Variable names (keeps track of what the user defines the variable as)
X_var = None
y_var = None


def check_X(lines) -> tuple[bool, str]:
    # Create `X` using `np.random.rand()` which has 500 samples and 7 features
    # {'variable': 'X', 'function': 'np.random.rand', 'args': ['num_samples', 'num_features'], 'kwargs': {}}
    # {'variable': 'X', 'function': 'np.random.rand', 'args': ['500', '7'], 'kwargs': {}}
    global X_var
    function_calls = find_function_call(lines, 'np.random.rand')

    # Check if random.rand() is called
    if len(function_calls) == 0:
        return False, "np.random.rand() isn't called"
    
    # np.random.rand() should only be called once
    if len(function_calls) > 1:
        return False, 'np.random.rand() should only be called once'
    
    function_call = function_calls[0]

    # Make sure output of np.random.rand() is stored in a variable
    if function_call['variable'] is None:
        return False, "Make sure you're storing the output of np.random.rand() in a variable"

    X_var = function_call['variable']

    # Need to figure out how to determine if variables as passed as the parameters
    # and how to check the value of them to make sure they equal 500 and 7
    if function_call['args'] != ['500', '7']:
        return False, 'Did you pass the correct values in the instructions to np.random.rand()?'
    
    return True, ''


def check_y(lines) -> tuple[bool, str]:
    # GOAL: Create `y` using `np.random.randint()` which has the same amount of samples and outputs either 0 or 1
    # {'variable': 'y', 'function': 'np.random.randint', 'args': ['0', '2'], 'kwargs': {'size': 'num_samples'}}
    global y_var
    function_calls = find_function_call(lines, 'np.random.randint')
    
    # Check if random.randint() is called
    if len(function_calls) == 0:
        return False, "np.random.randint() isn't called"
    
    # np.random.randint() should only be called once
    if len(function_calls) > 1:
        return False, 'np.random.randint() should only be called once'
    
    function_call = function_calls[0]

    # Make sure output of np.random.randint() is stored in a variable
    if function_call['variable'] is None:
        return False, "Make sure you're storing the output of np.random.randint() in a variable"

    y_var = function_call['variable']

    if function_call['args'] != ['0', '2']:
        return False, 'Did you provide the correct low and high bounds specified in the instructions?'

    if function_call['kwargs'] != {'size': '500'}:
        return False, "The 'size' parameter either has the incorrect value or isn't specified in the function call"

    return True, ''


def check_split(lines) -> tuple[bool, str]:
    # GOAL: Split the dataset where the train dataset is 70% of the original dataset
    # {'variable': ('X_train', 'X_test', 'y_train', 'y_test'), 'function': 'train_test_split', 'args': ['X', 'y'], 'kwargs': {'test_size': '0.3'}}
    global X_var
    global y_var
    function_calls = find_function_call(lines, 'train_test_split')

    # Check if train_test_split() is called
    if len(function_calls) == 0:
        return False, "train_test_split() isn't called"
    
    # train_test_split() should only be called once
    if len(function_calls) > 1:
        return False, 'train_test_split() should only be called once'
    
    function_call = function_calls[0]

    # Make sure output is stored in a variable
    if function_call['variable'] is None:
        return False, "Make sure you're storing the output of np.random.randint() in variables for your train and test datasets (HINT: It's 4 variables)"

    solution_args = [X_var, y_var]
    if function_call['args'] != solution_args:
        return False, 'Did you provide the correct variables for X and y?'
    
    solution_kwargs = {'test_size': '0.3'}
    if function_call['kwargs'] != solution_kwargs:
        return False, "Did you correctly set the 'test_size' parameter so that the training dataset is 70% of the original dataset?"

    return True, ''


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print('Usage: verify <user_script>.py')
        sys.exit(1)
    
    script_path = sys.argv[1]
    lines = extract_python_details(script_path)

    red_text_code = '\033[31m'
    green_text_code = '\033[32m'
    reset_code = '\033[0m'

    checks = [check_X, check_y, check_split]
    for i in range(len(checks)):
        check_func = checks[i]
        is_correct, error_msg = check_func(lines)
        if is_correct:
            print(f'{green_text_code}Step {i + 1} Passed{reset_code}')
        else:
            print(f'{red_text_code}Step {i + 1} Failed{reset_code}')
            print(error_msg)
            sys.exit(1)

    print('Congratulations! You have passed this challenge! Here is your flag:')
    print_flag()
